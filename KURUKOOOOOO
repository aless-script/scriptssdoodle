-- Combined Auto Encounter & Chain Hunter
-- Fixed with proper battle handling from reference

-- Safety checks
if not game or not game.GetService then return end

-- Initialize _G.AutoEncounter first before using it
_G.AutoEncounter = _G.AutoEncounter or {
    Active = false,
    ChainMode = false,
    CurrentZone = nil,
    Delay = 2,
    InBattle = false,
    Filters = {
        Species = "",
        Shiny = false,
        Misprint = false,
        HiddenTrait = false,
        Gender = "Any",
        MinStars = 0,
        MinIV = 0,
        MoveName = "Scratch"
    },
    Stats = {
        Encounters = 0,
        Chain = 0
    }
}

-- Use local reference
local env = _G

local player = game:GetService("Players").LocalPlayer
local remotes = player:WaitForChild("Remotes", 10)
if not remotes then return end
local dudeWhyld = remotes:WaitForChild("DudeWhyld", 5)
local startBattle = remotes:WaitForChild("StartBattle", 5)

-- Get Client for proper battle API access
local Client = nil
local MainGui = nil
local BattleGui = nil
local ActionBar = nil
local PartyGui = nil

task.spawn(function()
    pcall(function()
        local playerGui = player:WaitForChild("PlayerGui", 10)
        MainGui = playerGui:WaitForChild("MainGui", 10)
        if MainGui then
            BattleGui = MainGui:WaitForChild("MainBattle", 10)
            PartyGui = MainGui:WaitForChild("PartyUI", 10)
            if BattleGui then
                local BottomBar = BattleGui:WaitForChild("BottomBar", 5)
                if BottomBar then
                    ActionBar = BottomBar:WaitForChild("Actions", 5)
                end
            end
        end
        
        local packer = player:WaitForChild("Packer", 10)
        if packer then
            Client = require(packer:WaitForChild("Client"))
        end
    end)
end)

-- Zone Map (expanded)
local zoneEncounters = {
    ["025_Sweetsville"] = "WildGrass",
    ["033_Academy"] = "WildGrass",
    ["029_SubwayStation"] = "WildGrass",
    ["TheCarnival"] = "WildGrass",
    ["026_CrystalCaverns"] = "WildGrass",
    ["027_VolcanicCove"] = "WildGrass",
    ["028_FrozenTundra"] = "WildGrass",
    ["006_Route2"] = "WildGrass",
    ["007_Lakewood"] = "WildGrass",
    ["010_Route3"] = "WildGrass",
    ["013_Route4"] = "WildGrass",
    ["017_Crossroads"] = "WildGrass",
    ["018_CrystalCaverns"] = "WildGrass",
    ["024_Route5"] = "WildGrass",
}

-- GUI Creation
local gui = Instance.new("ScreenGui")
gui.Name = "CompactAutoEncounter"
gui.ResetOnSpawn = false
gui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

local main = Instance.new("Frame")
main.Name = "MainFrame"
main.Size = UDim2.new(0, 220, 0, 450)
main.Position = UDim2.new(0.05, 0, 0.5, -225)
main.BackgroundColor3 = Color3.fromRGB(20, 20, 25)
main.BorderSizePixel = 0
main.Active = true
main.Draggable = true
main.Parent = gui

local uicorner = Instance.new("UICorner")
uicorner.CornerRadius = UDim.new(0, 8)
uicorner.Parent = main

-- Header
local title = Instance.new("TextLabel")
title.Size = UDim2.new(1, -30, 0, 30)
title.Position = UDim2.new(0, 10, 0, 0)
title.BackgroundTransparency = 1
title.Text = "‚öîÔ∏è Auto Encounter"
title.TextColor3 = Color3.fromRGB(255, 255, 255)
title.Font = Enum.Font.GothamBold
title.TextSize = 14
title.TextXAlignment = Enum.TextXAlignment.Left
title.Parent = main

local closeBtn = Instance.new("TextButton")
closeBtn.Size = UDim2.new(0, 25, 0, 25)
closeBtn.Position = UDim2.new(1, -30, 0, 2.5)
closeBtn.BackgroundColor3 = Color3.fromRGB(200, 50, 50)
closeBtn.Text = "X"
closeBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
closeBtn.Font = Enum.Font.GothamBold
closeBtn.Parent = main
Instance.new("UICorner", closeBtn).CornerRadius = UDim.new(0, 4)

closeBtn.MouseButton1Click:Connect(function()
    env.AutoEncounter.Active = false
    gui:Destroy()
end)

-- Info Display
local infoFrame = Instance.new("Frame")
infoFrame.Size = UDim2.new(1, -20, 0, 160)
infoFrame.Position = UDim2.new(0, 10, 0, 35)
infoFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 35)
infoFrame.Parent = main
Instance.new("UICorner", infoFrame).CornerRadius = UDim.new(0, 6)

local function createInfoLine(order, labelText)
    local label = Instance.new("TextLabel")
    label.Size = UDim2.new(1, -10, 0, 18)
    label.Position = UDim2.new(0, 5, 0, (order - 1) * 18 + 5)
    label.BackgroundTransparency = 1
    label.Text = labelText .. ": -"
    label.TextColor3 = Color3.fromRGB(200, 200, 200)
    label.Font = Enum.Font.Gotham
    label.TextSize = 11
    label.TextXAlignment = Enum.TextXAlignment.Left
    label.Parent = infoFrame
    return label
end

local infoLabels = {
    Name = createInfoLine(1, "Name"),
    Stars = createInfoLine(2, "Stars"),
    Trait = createInfoLine(3, "Trait"),
    Gender = createInfoLine(4, "Gender"),
    Misprint = createInfoLine(5, "Misprint"),
    Item = createInfoLine(6, "Item"),
    Equip = createInfoLine(7, "Equip"),
    Skin = createInfoLine(8, "Skin"),
}

-- Controls
local controlFrame = Instance.new("Frame")
controlFrame.Size = UDim2.new(1, -20, 0, 170)
controlFrame.Position = UDim2.new(0, 10, 0, 200)
controlFrame.BackgroundTransparency = 1
controlFrame.Parent = main

-- Mode Toggle
local chainModeBtn = Instance.new("TextButton")
chainModeBtn.Size = UDim2.new(1, 0, 0, 25)
chainModeBtn.BackgroundColor3 = Color3.fromRGB(60, 60, 65)
chainModeBtn.Text = "Chain Mode: OFF"
chainModeBtn.TextColor3 = Color3.fromRGB(200, 200, 200)
chainModeBtn.Font = Enum.Font.Gotham
chainModeBtn.TextSize = 12
chainModeBtn.Parent = controlFrame
Instance.new("UICorner", chainModeBtn).CornerRadius = UDim.new(0, 6)

chainModeBtn.MouseButton1Click:Connect(function()
    env.AutoEncounter.ChainMode = not env.AutoEncounter.ChainMode
    if env.AutoEncounter.ChainMode then
        chainModeBtn.BackgroundColor3 = Color3.fromRGB(50, 150, 255)
        chainModeBtn.Text = "Chain Mode: ON"
        chainModeBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
    else
        chainModeBtn.BackgroundColor3 = Color3.fromRGB(60, 60, 65)
        chainModeBtn.Text = "Chain Mode: OFF"
        chainModeBtn.TextColor3 = Color3.fromRGB(200, 200, 200)
    end
end)

-- Target Species Input
local speciesInput = Instance.new("TextBox")
speciesInput.Size = UDim2.new(1, 0, 0, 25)
speciesInput.Position = UDim2.new(0, 0, 0, 30)
speciesInput.BackgroundColor3 = Color3.fromRGB(45, 45, 50)
speciesInput.Text = ""
speciesInput.PlaceholderText = "Target Species"
speciesInput.TextColor3 = Color3.fromRGB(255, 255, 255)
speciesInput.Font = Enum.Font.Gotham
speciesInput.TextSize = 12
speciesInput.Parent = controlFrame
Instance.new("UICorner", speciesInput).CornerRadius = UDim.new(0, 6)
speciesInput:GetPropertyChangedSignal("Text"):Connect(function() env.AutoEncounter.Filters.Species = speciesInput.Text end)

-- Min Stars Input
local starsInput = Instance.new("TextBox")
starsInput.Size = UDim2.new(0.48, 0, 0, 25)
starsInput.Position = UDim2.new(0, 0, 0, 60)
starsInput.BackgroundColor3 = Color3.fromRGB(45, 45, 50)
starsInput.Text = ""
starsInput.PlaceholderText = "Min Stars"
starsInput.TextColor3 = Color3.fromRGB(255, 255, 255)
starsInput.Font = Enum.Font.Gotham
starsInput.TextSize = 12
starsInput.Parent = controlFrame
Instance.new("UICorner", starsInput).CornerRadius = UDim.new(0, 6)
starsInput:GetPropertyChangedSignal("Text"):Connect(function() env.AutoEncounter.Filters.MinStars = tonumber(starsInput.Text) or 0 end)

-- Hidden Trait Toggle
local htBtn = Instance.new("TextButton")
htBtn.Size = UDim2.new(0.48, 0, 0, 25)
htBtn.Position = UDim2.new(0.52, 0, 0, 60)
htBtn.BackgroundColor3 = Color3.fromRGB(60, 60, 65)
htBtn.Text = "HT: OFF"
htBtn.TextColor3 = Color3.fromRGB(200, 200, 200)
htBtn.Font = Enum.Font.Gotham
htBtn.TextSize = 11
htBtn.Parent = controlFrame
Instance.new("UICorner", htBtn).CornerRadius = UDim.new(0, 6)
htBtn.MouseButton1Click:Connect(function()
    env.AutoEncounter.Filters.HiddenTrait = not env.AutoEncounter.Filters.HiddenTrait
    htBtn.Text = env.AutoEncounter.Filters.HiddenTrait and "HT: ON" or "HT: OFF"
    htBtn.BackgroundColor3 = env.AutoEncounter.Filters.HiddenTrait and Color3.fromRGB(50, 150, 255) or Color3.fromRGB(60, 60, 65)
    htBtn.TextColor3 = env.AutoEncounter.Filters.HiddenTrait and Color3.fromRGB(255, 255, 255) or Color3.fromRGB(200, 200, 200)
end)

-- Move Name Input
local moveInput = Instance.new("TextBox")
moveInput.Size = UDim2.new(1, 0, 0, 25)
moveInput.Position = UDim2.new(0, 0, 0, 90)
moveInput.BackgroundColor3 = Color3.fromRGB(45, 45, 50)
moveInput.Text = "Scratch"
moveInput.PlaceholderText = "Move Name (for Kill)"
moveInput.TextColor3 = Color3.fromRGB(255, 255, 255)
moveInput.Font = Enum.Font.Gotham
moveInput.TextSize = 12
moveInput.Parent = controlFrame
Instance.new("UICorner", moveInput).CornerRadius = UDim.new(0, 6)
moveInput:GetPropertyChangedSignal("Text"):Connect(function() env.AutoEncounter.Filters.MoveName = moveInput.Text end)

-- Start/Stop
local toggleBtn = Instance.new("TextButton")
toggleBtn.Size = UDim2.new(1, 0, 0, 35)
toggleBtn.Position = UDim2.new(0, 0, 1, -35)
toggleBtn.BackgroundColor3 = Color3.fromRGB(50, 200, 100)
toggleBtn.Text = "‚ñ∂Ô∏è Start"
toggleBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
toggleBtn.Font = Enum.Font.GothamBold
toggleBtn.TextSize = 14
toggleBtn.Parent = controlFrame
Instance.new("UICorner", toggleBtn).CornerRadius = UDim.new(0, 6)

toggleBtn.MouseButton1Click:Connect(function()
    env.AutoEncounter.Active = not env.AutoEncounter.Active
    if env.AutoEncounter.Active then
        toggleBtn.Text = "‚è∏Ô∏è Stop"
        toggleBtn.BackgroundColor3 = Color3.fromRGB(255, 100, 100)
    else
        toggleBtn.Text = "‚ñ∂Ô∏è Start"
        toggleBtn.BackgroundColor3 = Color3.fromRGB(50, 200, 100)
    end
end)

-- Logic Functions
local function updateDisplay(data)
    if not data then return end
    infoLabels.Name.Text = "Name: " .. (data.Name or data.RealName or "Unknown")
    infoLabels.Stars.Text = "Stars: " .. (data.Star or 0) .. "‚≠ê"
    
    local trait = data.Ability or data.Trait or data.HiddenTrait or "None"
    infoLabels.Trait.Text = "Trait: " .. tostring(trait)
    
    local gender = "Genderless"
    if data.Gender == "Male" then gender = "‚ôÇ Male" end
    if data.Gender == "Female" then gender = "‚ôÄ Female" end
    infoLabels.Gender.Text = "Gender: " .. gender
    
    local misprint = "No"
    if data.Shiny then misprint = "Shiny" end
    if data.Color and data.Color ~= "Normal" then misprint = data.Color end
    infoLabels.Misprint.Text = "Misprint: " .. misprint
    
    infoLabels.Item.Text = "Item: " .. (data.Item or "None")
    infoLabels.Equip.Text = "Equip: " .. (data.Equipment or "None")
    infoLabels.Skin.Text = "Skin: " .. (data.Skin or "None")
end

local function checkMatch(data)
    if env.AutoEncounter.Filters.Species ~= "" then
        local name = (data.Name or data.RealName or ""):lower()
        if not name:find(env.AutoEncounter.Filters.Species:lower()) then
            return false, "Species Mismatch"
        end
    end
    
    if (data.Star or 0) < env.AutoEncounter.Filters.MinStars then
        return false, "Low Stars"
    end
    
    if env.AutoEncounter.Filters.HiddenTrait then
        if not data.HiddenTrait then
            return false, "No HT"
        end
    end

    return true, "Match"
end

-- EndTurn function from reference script
local function EndTurn()
    if not Client or not Client.Network then return end
    pcall(function()
        local UpValues = getupvalues(Client.Network.BindEvent)
        for i,v in pairs(UpValues) do
            if typeof(v) == "table" and v["ForceEnd"] ~= nil then
                v.ForceEnd()
                break
            end
        end
    end)
end

-- Get current doodle (from reference)
local function GetOutDoodle()
    if not Client or not Client.Battle or Client.Battle.CurrentBattle == nil then
        return nil
    end
    
    local Party = Client.Battle.CurrentBattle["Player1Party"]
    if Party and #Party > 0 then
        return Party[1]
    end
    return nil
end

-- Get enemy doodle (from reference)
local function GetEnemyDoodle()
    if not Client or not Client.Battle or Client.Battle.CurrentBattle == nil then
        return nil
    end
    
    local Party = Client.Battle.CurrentBattle["Player2Party"]
    if Party and #Party > 0 then
        return Party[1]
    end
    return nil
end

-- Battle action handler using proper methods from reference
local function executeBattleAction(YourDoodle, EnemyDoodle, actionType)
    if not Client or not Client.Network then 
        warn("[AutoEncounter] Client.Network not available")
        return 
    end
    
    if not YourDoodle then
        warn("[AutoEncounter] No doodle available")
        return
    end
    
    -- Wait for action bar to be visible
    local maxWait = 50
    local waited = 0
    while waited < maxWait do
        if ActionBar and ActionBar.Visible == true then
            break
        end
        if not Client.Battle or Client.Battle.CurrentBattle == nil then
            return -- Battle ended
        end
        task.wait(0.1)
        waited = waited + 1
    end
    
    task.wait(0.3) -- Additional stability delay
    
    if actionType == "run" then
        -- Run away using Client.Network:post
        pcall(function()
            Client.Network:post("BattleAction", {
                [1] = {
                    ["Target"] = "RunAway",
                    ["ActionType"] = "Run",
                    ["User"] = YourDoodle.ID,
                }
            })
            print("[AutoEncounter] üèÉ Running away")
            task.wait(0.1)
            ActionBar.Visible = false
            EndTurn()
        end)
        
    elseif actionType == "attack" then
        if not EnemyDoodle then
            warn("[AutoEncounter] No enemy doodle to attack")
            return
        end
        
        -- Find best move using type effectiveness (from reference script)
        local BestMatchup = nil
        local HighestMultiplier = -100
        
        pcall(function()
            if YourDoodle.Moves and Client.ClientDatabase and Client.Typings then
                for i,v in pairs(YourDoodle.Moves) do
                    local MoveData = Client.ClientDatabase:GetMoveData(v.Name)
                    if MoveData and MoveData.Type then
                        local MoveType = MoveData.Type
                        local Multiplier, Message = Client.Typings:GetEffectiveness(YourDoodle, EnemyDoodle, MoveType)
                        
                        if MoveData.Power ~= nil and Multiplier > HighestMultiplier then
                            HighestMultiplier = Multiplier
                            BestMatchup = v.Name
                        end
                    end
                end
            end
        end)
        
        -- Execute the attack
        if BestMatchup ~= nil then
            pcall(function()
                Client.Network:post("BattleAction", {
                    [1] = {
                        ["Target"] = EnemyDoodle.ID,
                        ["ActionType"] = "Attack",
                        ["Action"] = BestMatchup,
                        ["User"] = YourDoodle.ID,
                    }
                })
                print("[AutoEncounter] ‚öîÔ∏è Attacking with:", BestMatchup, "| Effectiveness:", HighestMultiplier)
                ActionBar.Visible = false
                task.wait(0.1)
                EndTurn()
            end)
        elseif YourDoodle.Moves and #YourDoodle.Moves > 0 then
            -- Fallback: use random move
            local randomMove = YourDoodle.Moves[math.random(1, #YourDoodle.Moves)].Name
            pcall(function()
                Client.Network:post("BattleAction", {
                    [1] = {
                        ["Target"] = EnemyDoodle.ID,
                        ["ActionType"] = "Attack",
                        ["Action"] = randomMove,
                        ["User"] = YourDoodle.ID,
                    }
                })
                print("[AutoEncounter] ‚öîÔ∏è Attacking with random move:", randomMove)
                ActionBar.Visible = false
                task.wait(0.1)
                EndTurn()
            end)
        else
            warn("[AutoEncounter] No moves available")
        end
    end
end

-- Battle Event Hook with improved logic
startBattle.OnClientEvent:Connect(function(battleData)
    if not env.AutoEncounter.Active then return end
    
    env.AutoEncounter.InBattle = true
    
    -- Wait a moment for battle to fully initialize
    task.wait(0.3)
    
    -- Get doodles using proper methods
    local wildDoodle = GetEnemyDoodle()
    local myDoodle = GetOutDoodle()
    
    if not wildDoodle or not myDoodle then
        warn("[AutoEncounter] Could not get doodle data")
        env.AutoEncounter.InBattle = false
        return
    end
    
    updateDisplay(wildDoodle)
    env.AutoEncounter.Stats.Encounters = env.AutoEncounter.Stats.Encounters + 1
    
    if env.AutoEncounter.ChainMode then
        local isMatch, reason = checkMatch(wildDoodle)
        local speciesMatch = env.AutoEncounter.Filters.Species == "" or 
                           (wildDoodle.Name or ""):lower():find(env.AutoEncounter.Filters.Species:lower())
        
        if isMatch then
            -- Perfect match found!
            env.AutoEncounter.Active = false
            env.AutoEncounter.InBattle = false
            toggleBtn.Text = "üéâ Found!"
            toggleBtn.BackgroundColor3 = Color3.fromRGB(255, 215, 0)
            print("[AutoEncounter] ‚ú® MATCH FOUND! ‚ú®", wildDoodle.Name)
        else
            print("[AutoEncounter] Check: Species=" .. tostring(speciesMatch) .. " | " .. reason)
            
            -- Spawn battle action in separate thread
            task.spawn(function()
                if speciesMatch then
                    -- Right species, wrong stats - kill to maintain chain
                    print("[AutoEncounter] ‚öîÔ∏è Killing for chain (Species match, " .. reason .. ")")
                    executeBattleAction(myDoodle, wildDoodle, "attack")
                    env.AutoEncounter.Stats.Chain = env.AutoEncounter.Stats.Chain + 1
                else
                    -- Wrong species - run away
                    print("[AutoEncounter] üèÉ Running (Wrong species)")
                    executeBattleAction(myDoodle, wildDoodle, "run")
                    env.AutoEncounter.Stats.Chain = 0 -- Reset chain
                end
                
                -- Wait for battle to end
                repeat task.wait(0.5) until not Client or not Client.Battle or Client.Battle.CurrentBattle == nil
                task.wait(1)
                env.AutoEncounter.InBattle = false
            end)
        end
    else
        -- Not in chain mode, just run from everything
        task.spawn(function()
            executeBattleAction(myDoodle, wildDoodle, "run")
            repeat task.wait(0.5) until not Client or not Client.Battle or Client.Battle.CurrentBattle == nil
            task.wait(1)
            env.AutoEncounter.InBattle = false
        end)
    end
end)

-- Check if standing on grass/encounter area
local function CheckGrass()
    if not Client or not Client.DataManager or not Client.DataManager.RegionData then
        return nil
    end
    
    local char = player.Character
    if not char or not char:FindFirstChild("HumanoidRootPart") then
        return nil
    end
    
    local RaycastParams = RaycastParams.new()
    RaycastParams.FilterType = Enum.RaycastFilterType.Blacklist
    RaycastParams.FilterDescendantsInstances = {char, game.Workspace.Terrain}
    
    local Check = game.Workspace:Raycast(char.HumanoidRootPart.Position, Vector3.new(0,-10,0), RaycastParams)
    
    if Check and Check.Instance then
        local CurrentChunk = Client.DataManager.RegionData.ChunkName or Client.DataManager.RegionData.Reference
        local ChunkInfo = Client.Network:get("RequestChunkInfo", CurrentChunk)
        
        if ChunkInfo and ChunkInfo.Encounters and ChunkInfo.Encounters[Check.Instance.Name] then
            return Check.Instance.Name
        end
    end
    
    return nil
end

-- Improved zone detection
local function detectCurrentZone()
    if not Client or not Client.DataManager or not Client.DataManager.RegionData then
        return nil
    end
    
    local CurrentChunk = Client.DataManager.RegionData.ChunkName or Client.DataManager.RegionData.Reference
    if CurrentChunk then
        return CurrentChunk
    end
    
    return nil
end

-- Main Loop with improved encounter triggering
task.spawn(function()
    while task.wait(0.5) do
        if env.AutoEncounter.Active and not env.AutoEncounter.InBattle and Client and Client.Battle then
            local char = player.Character
            if char and char:FindFirstChild("HumanoidRootPart") then
                -- Get current zone and grass type
                local zone = detectCurrentZone()
                local grassType = CheckGrass()
                
                if zone and grassType and Client.Battle.WildBattIe then
                    -- Trigger encounter using proper method
                    local success, err = pcall(function()
                        Client.Battle.WildBattIe(nil, nil, grassType)
                    end)
                    
                    if success then
                        print("[AutoEncounter] üé≤ Triggered encounter in:", zone, "| Type:", grassType)
                        -- Wait before next encounter
                        task.wait(env.AutoEncounter.Delay)
                    else
                        warn("[AutoEncounter] Failed to trigger:", err)
                    end
                end
            end
        end
    end
end)

-- Safe Parent
local success = pcall(function()
    gui.Parent = game:GetService("CoreGui")
end)
if not success then 
    gui.Parent = player.PlayerGui 
end

print("[AutoEncounter] Script loaded successfully!")
